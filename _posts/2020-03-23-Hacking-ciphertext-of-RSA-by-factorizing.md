---
layout: post
title: Hacking ciphertext of RSA by factorizing
---

# Hacking ciphertext of RSA by factorizing

In this post, we break RSA algorithm with the library of Crypto in Python. Suppose that we have the basic knowledge of RSA and how it works.

Bob would like to send the message *m* to Alice. He encrypts this message with the public key of Alice.

For generating RSA key, Alice chooses a couple of prime numbers: *p* and *q* (very big). Alice also chooses a number *e* which is co-prime with *$\phi$=(p-1)(q-1)*.

We know that *(n, e)* is the public key where *n = pq*. From this key, Bob can encrypt his message.

In this example, the values of *n* and *e* are below:

    n = 9010912747277787249738727439840427055736519196538871349093408340706668231808840540195374015916168031416186859836416053338250477003776576736854137538279810042409758765948034443613881324504120707334213544491046703922409406729564516371394804946909037646047891880347940067132730874804943893719672960932378043325067514786209219718314429979032869544980643978919561908707109629612202311323626173343456843249212057093980583352634168733656443959925428846968193413110401346035535595817965624054783296380268863401241570313602685481219583686719199499297832165308522137209299081956650614940546284136240753995440003473611843518083
    e = 65537

We also know the ciphertext:

    ciphertext = 1602989376274354269985963116549561484330811074011540081800290387354806165932943955141921946260544029644225599356622133439709046026356784514316764929191491171733617490605688176348390502645856824087951541803994252794283132484235741601168056020901839987142777329119071921254517524303612956232247571108777081902624820119067014894042505566853882894023848799686515984566752138557053103927217027956956027403477882942183858429585950172479849821553014433417650830611408252312910561488031937838277592289719035945277058628990644281715010808719769467790547389517508271099854899621389421269694156912390382012070703473633070280568

From these three value, we would like to obtain the plaintext *m*. The first step is to factorize *n* into *p* and *q*. We could use the tool on [factordb.com](http://factordb.com) to do this. In doing so, we obtain the below values:

    p = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
    q = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559

We then use the library Crypto in Python to calculate the private key *d* of Alice. Recall that *d* is the inversion of *e* modulo $\phi$.

```python
from Crypto.Util.number import inverse, bytes_to_long, long_to_bytes

ciphertext=1602989376274354269985963116549561484330811074011540081800290387354806165932943955141921946260544029644225599356622133439709046026356784514316764929191491171733617490605688176348390502645856824087951541803994252794283132484235741601168056020901839987142777329119071921254517524303612956232247571108777081902624820119067014894042505566853882894023848799686515984566752138557053103927217027956956027403477882942183858429585950172479849821553014433417650830611408252312910561488031937838277592289719035945277058628990644281715010808719769467790547389517508271099854899621389421269694156912390382012070703473633070280568

p=97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637

q=92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559

n = p*q
phi = (p-1)*(q-1)
e = 65537
d = inverse(e, phi)

message = pow(ciphertext, d, n)
message = long_to_bytes(message) # integer to string
```
Bravo! The final message is "I love you".

However, we can only apply this method in the case that the number of *n* is small enough. It depends on the ability of the tool [factordb.com](http://factordb.com).